<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>earthtown - the sanctuary</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&family=Inter:wght@300;400;500&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: #0a0a0a;
            color: #e8e8e8;
            overflow: hidden;
            height: 100vh;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
        }
        
        /* Dreamcore floating background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 15% 20%, rgba(168, 212, 232, 0.04) 0%, transparent 40%),
                radial-gradient(circle at 85% 75%, rgba(127, 194, 155, 0.04) 0%, transparent 40%),
                radial-gradient(circle at 50% 50%, rgba(247, 127, 0, 0.02) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
            animation: dreamFloat 25s ease-in-out infinite alternate;
        }
        
        @keyframes dreamFloat {
            0% { opacity: 0.4; transform: scale(1); }
            100% { opacity: 0.7; transform: scale(1.05); }
        }

        /* Room container */
        .room-container {
            display: grid;
            grid-template-rows: auto 1fr auto;
            height: 100vh;
        }

        /* Header */
        .room-header {
            background: rgba(10, 10, 10, 0.85);
            border-bottom: 2px solid rgba(241, 250, 238, 0.2);
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            backdrop-filter: blur(10px);
        }

        .room-info {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .back-button {
            font-family: 'VT323', monospace;
            font-size: 1.2rem;
            color: #a8a8a8;
            text-decoration: none;
            padding: 8px 15px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            transition: all 0.3s ease;
        }

        .back-button:hover {
            color: #f1faee;
            border-color: rgba(241, 250, 238, 0.4);
        }

        .room-title {
            font-family: 'VT323', monospace;
            font-size: 2rem;
            color: #f1faee;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .online-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
            color: #888;
        }

        .pulse-dot {
            width: 10px;
            height: 10px;
            background: #6b8e6b;
            border-radius: 50%;
            animation: pulse-glow 2s infinite;
            box-shadow: 0 0 8px rgba(107, 142, 107, 0.6);
        }

        @keyframes pulse-glow {
            0%, 100% { 
                opacity: 1; 
                transform: scale(1);
                box-shadow: 0 0 8px rgba(107, 142, 107, 0.6);
            }
            50% { 
                opacity: 0.7; 
                transform: scale(0.95);
                box-shadow: 0 0 15px rgba(107, 142, 107, 0.8);
            }
        }

        /* Main area */
        .main-area {
            display: grid;
            grid-template-columns: 1fr 350px;
            height: 100%;
            overflow: hidden;
        }

        /* Room space */
        .room-space {
            position: relative;
            background: #0a0a0a;
            overflow: visible;
        }

        .room-ambient {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.3;
        }

        .ambient-orb {
            position: absolute;
            border-radius: 50%;
            filter: blur(80px);
            animation: float-ambient 25s infinite ease-in-out;
        }

        .orb-1 {
            width: 400px;
            height: 400px;
            background: rgba(139, 115, 139, 0.05);
            top: -100px;
            left: -100px;
        }

        .orb-2 {
            width: 300px;
            height: 300px;
            background: rgba(107, 142, 107, 0.05);
            bottom: -50px;
            right: -50px;
            animation-delay: 8s;
        }

        @keyframes float-ambient {
            0%, 100% { transform: translate(0, 0); }
            50% { transform: translate(50px, -50px); }
        }

        /* Avatars */
        .avatars-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: visible;
        }

        .avatar {
            position: absolute;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
            transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        
        .avatar:hover {
            transform: scale(1.05);
            z-index: 10;
        }

        .avatar-image {
            width: 150px;
            height: 150px;
            image-rendering: pixelated;
            position: relative;
            overflow: visible;
        }

        .avatar-image * {
            overflow: visible;
        }

        .avatar-image img {
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            filter: none; /* No glow for other users */
            background: none;
            pointer-events: none;
            user-select: none;
            -webkit-user-drag: none;
        }

        .avatar.current-user {
            z-index: 100 !important; /* Always on top so you can drag it */
        }

        .avatar.current-user .avatar-image img {
            filter: drop-shadow(0 0 10px rgba(241, 250, 238, 0.5)); /* Glow only on your avatar */
        }

        .avatar-name {
            font-family: 'VT323', monospace;
            font-size: 1rem;
            background: rgba(0, 0, 0, 0.05);
            padding: 3px 10px;
            border-radius: 4px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            white-space: nowrap;
        }

        /* Archetype colors */
        .archetype-hero { color: #f1faee; }
        .archetype-sage { color: #9b87c7; }
        .archetype-explorer { color: #7fc29b; }
        .archetype-rebel { color: #c77a7a; }
        .archetype-magician { color: #c79bd9; }
        .archetype-lover { color: #d99ba3; }
        .archetype-jester { color: #f0c77a; }
        .archetype-innocent { color: #b5d4e8; }
        .archetype-caregiver { color: #a8d4a8; }
        .archetype-ruler { color: #f1faee; }
        .archetype-creator { color: #c7a77a; }
        .archetype-everyman { color: #a8a8a8; }

        /* Avatar detail popup */
        .avatar-detail {
            position: fixed;
            background: rgba(0, 0, 0, 0.05);
            border: 3px solid rgba(241, 250, 238, 0.4);
            border-radius: 12px;
            padding: 25px;
            min-width: 250px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            animation: popIn 0.3s ease;
        }

        @keyframes popIn {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .detail-header {
            display: flex;
            align-items: center;
            gap: 15px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(241, 250, 238, 0.2);
        }

        .detail-avatar {
            width: 70px;
            height: 70px;
            image-rendering: pixelated;
        }

        .detail-avatar img {
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }

        .detail-info {
            flex: 1;
        }

        .detail-username {
            font-family: 'VT323', monospace;
            font-size: 1.5rem;
            margin-bottom: 5px;
        }

        .detail-archetype {
            font-family: 'VT323', monospace;
            font-size: 1.1rem;
            opacity: 0.8;
        }

        .detail-close {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 30px;
            height: 30px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.2rem;
            color: #888;
        }

        .detail-close:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(241, 250, 238, 0.4);
            color: #f1faee;
        }

        /* Chat sidebar */
        .chat-sidebar {
            background: rgba(0, 0, 0, 0.05);
            border-left: 2px solid rgba(241, 250, 238, 0.2);
            display: flex;
            flex-direction: column;
            backdrop-filter: blur(10px);
        }

        .chat-header {
            padding: 20px;
            border-bottom: 2px solid rgba(241, 250, 238, 0.2);
        }

        .chat-title {
            font-family: 'VT323', monospace;
            font-size: 1.5rem;
            color: #f1faee;
            margin-bottom: 10px;
        }

        .users-in-room {
            font-size: 0.85rem;
            color: #888;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .message {
            display: flex;
            gap: 10px;
            animation: messageSlideIn 0.3s ease;
        }

        @keyframes messageSlideIn {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .message-avatar {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            flex-shrink: 0;
            image-rendering: pixelated;
        }

        .message-content {
            flex: 1;
            min-width: 0;
        }

        .message-header {
            display: flex;
            align-items: baseline;
            gap: 8px;
            margin-bottom: 3px;
        }

        .message-author {
            font-family: 'VT323', monospace;
            font-size: 1rem;
        }

        .message-time {
            font-size: 0.7rem;
            color: #666;
        }

        .message-text {
            font-size: 0.9rem;
            color: #ccc;
            line-height: 1.4;
            word-wrap: break-word;
        }

        .chat-input-container {
            padding: 20px;
            border-top: 2px solid rgba(241, 250, 238, 0.2);
        }

        .chat-input {
            width: 100%;
            padding: 12px 15px;
            background: rgba(0, 0, 0, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #e8e8e8;
            font-family: 'Inter', sans-serif;
            font-size: 0.95rem;
            transition: all 0.3s ease;
        }

        .chat-input:focus {
            outline: none;
            border-color: rgba(241, 250, 238, 0.6);
            background: rgba(0, 0, 0, 0.05);
        }

        .chat-input::placeholder {
            color: #666;
        }

        /* Music control */
        .music-control {
            background: rgba(0, 0, 0, 0.05);
            border-top: 2px solid rgba(241, 250, 238, 0.2);
            padding: 20px 30px;
            display: flex;
            align-items: center;
            gap: 20px;
            backdrop-filter: blur(10px);
        }

        .now-playing {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .album-art {
            width: 50px;
            height: 50px;
            background: rgba(241, 250, 238, 0.2);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
        }

        .track-info {
            flex: 1;
            min-width: 0;
        }

        .track-title {
            font-family: 'VT323', monospace;
            font-size: 1.2rem;
            color: #f1faee;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .track-artist {
            font-size: 0.85rem;
            color: #888;
        }

        .playback-controls {
            display: flex;
            gap: 10px;
        }

        .control-btn {
            width: 40px;
            height: 40px;
            background: rgba(241, 250, 238, 0.2);
            border: 2px solid rgba(241, 250, 238, 0.4);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.2rem;
        }

        .control-btn:hover {
            background: rgba(241, 250, 238, 0.05);
            border-color: rgba(241, 250, 238, 0.6);
            transform: scale(1.05);
        }

        .queue-btn {
            font-family: 'VT323', monospace;
            font-size: 1rem;
            padding: 10px 20px;
            background: transparent;
            border: 2px solid rgba(241, 250, 238, 0.4);
            border-radius: 6px;
            color: #f1faee;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .queue-btn:hover {
            background: rgba(241, 250, 238, 0.2);
            border-color: rgba(241, 250, 238, 0.6);
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .main-area {
                grid-template-columns: 1fr;
                grid-template-rows: 1fr auto;
            }

            .chat-sidebar {
                border-left: none;
                border-top: 2px solid rgba(241, 250, 238, 0.2);
                max-height: 40vh;
            }
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(241, 250, 238, 0.05);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(241, 250, 238, 0.05);
        }
    
    /* Music Modal */
    .modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 3000;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .modal-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        backdrop-filter: blur(10px);
    }

    .modal-content {
        position: relative;
        background: #0a0a0a;
        border: 2px solid rgba(241, 250, 238, 0.2);
        border-radius: 16px;
        width: 90%;
        max-width: 700px;
        max-height: 85vh;
        overflow: hidden;
        display: flex;
        flex-direction: column;
    }

    .modal-header {
        padding: 25px 30px;
        border-bottom: 1px solid rgba(241, 250, 238, 0.1);
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .modal-header h2 {
        font-family: 'VT323', monospace;
        font-size: 2.2rem;
        color: #f1faee;
        letter-spacing: 2px;
    }

    .modal-close {
        background: none;
        border: none;
        color: #f1faee;
        font-size: 2.5rem;
        cursor: pointer;
        line-height: 1;
    }

    .queue-tabs {
        display: flex;
        border-bottom: 1px solid rgba(241, 250, 238, 0.1);
    }

    .tab-btn {
        flex: 1;
        padding: 18px;
        background: none;
        border: none;
        color: #888;
        font-family: 'VT323', monospace;
        font-size: 1.3rem;
        cursor: pointer;
        transition: all 0.3s;
        letter-spacing: 1px;
        position: relative;
    }

    .tab-btn.active {
        color: #f1faee;
    }

    .tab-btn.active::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 2px;
        background: linear-gradient(90deg, #f77f00, #d62828, #6a4c93);
    }

    .queue-section {
        padding: 25px 30px;
        overflow-y: auto;
        display: none;
        flex: 1;
    }

    .queue-section.active {
        display: block;
    }

    .upload-area {
        margin-bottom: 25px;
    }

    .upload-box {
        border: 2px dashed rgba(241, 250, 238, 0.2);
        padding: 40px 30px;
        text-align: center;
        cursor: pointer;
        border-radius: 12px;
        transition: all 0.3s;
        margin-bottom: 15px;
    }

    .upload-box:hover {
        border-color: rgba(45, 106, 79, 0.4);
        background: rgba(45, 106, 79, 0.05);
    }

    .upload-icon {
        font-size: 3rem;
        display: block;
        margin-bottom: 10px;
    }

    .upload-box p {
        color: #888;
        font-size: 0.95rem;
    }

    .url-input-group {
        display: flex;
        gap: 12px;
    }

    .url-input-group input {
        flex: 1;
        padding: 12px 18px;
        background: rgba(241, 250, 238, 0.03);
        border: 1px solid rgba(241, 250, 238, 0.15);
        border-radius: 8px;
        color: #f1faee;
        font-family: 'Inter', sans-serif;
        font-size: 0.95rem;
    }

    .url-input-group input::placeholder {
        color: #555;
    }

    .url-input-group button {
        padding: 12px 30px;
        background: #2d6a4f;
        border: none;
        border-radius: 8px;
        color: #f1faee;
        font-family: 'VT323', monospace;
        font-size: 1.2rem;
        cursor: pointer;
        letter-spacing: 1px;
    }

    .queue-list {
        display: flex;
        flex-direction: column;
        gap: 10px;
    }

    .queue-item {
        padding: 15px 18px;
        background: rgba(241, 250, 238, 0.03);
        border: 1px solid rgba(241, 250, 238, 0.1);
        border-radius: 8px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .queue-item-info {
        flex: 1;
    }

    .queue-item-title {
        font-family: 'VT323', monospace;
        font-size: 1.2rem;
        color: #f1faee;
        margin-bottom: 5px;
    }

    .queue-item-artist {
        font-size: 0.9rem;
        color: #888;
    }

    .queue-item-time {
        font-family: 'VT323', monospace;
        font-size: 1.1rem;
        color: #888;
        margin-left: 20px;
    }

    .pod-controls {
        padding: 20px;
        background: rgba(106, 76, 147, 0.05);
        border-bottom: 1px solid rgba(106, 76, 147, 0.2);
        display: flex;
        flex-direction: column;
        gap: 10px;
    }

    .pod-action-btn {
        padding: 12px 20px;
        border-radius: 8px;
        font-family: 'VT323', monospace;
        font-size: 1.2rem;
        cursor: pointer;
        border: 2px solid;
        transition: all 0.3s;
        letter-spacing: 1px;
    }

    .pod-action-btn:hover {
        transform: translateY(-2px);
        opacity: 0.8;
    }

    .pod-track-item {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 12px;
        background: rgba(10, 10, 10, 0.3);
        border: 1px solid rgba(241, 250, 238, 0.1);
        border-radius: 8px;
        margin-bottom: 8px;
    }

    .pod-track-controls {
        display: flex;
        gap: 5px;
        flex-shrink: 0;
    }

    .pod-track-btn {
        width: 32px;
        height: 32px;
        border-radius: 6px;
        border: 1px solid;
        cursor: pointer;
        font-size: 1rem;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
    }

    .pod-track-btn:hover {
        transform: scale(1.1);
    }

    .pod-track-info {
        flex: 1;
        min-width: 0;
    }

    .pod-track-note {
        width: 100%;
        padding: 6px;
        background: rgba(10, 10, 10, 0.5);
        border: 1px solid rgba(241, 250, 238, 0.1);
        border-radius: 4px;
        color: #f1faee;
        font-size: 0.85rem;
        font-family: 'Inter', sans-serif;
        margin-top: 5px;
    }

    .pod-info {
        text-align: center;
        padding: 50px 30px;
    }

    .pod-icon {
        font-size: 4rem;
        margin-bottom: 20px;
    }

    .pod-info h3 {
        font-family: 'VT323', monospace;
        font-size: 2rem;
        color: #f1faee;
        margin-bottom: 15px;
        letter-spacing: 2px;
    }

    .pod-info p {
        color: #888;
        margin-bottom: 30px;
        line-height: 1.6;
    }

    .pod-enter-btn {
        padding: 14px 40px;
        background: #f1faee;
        border: none;
        border-radius: 8px;
        color: #0a0a0a;
        font-family: 'VT323', monospace;
        font-size: 1.5rem;
        cursor: pointer;
        letter-spacing: 2px;
        position: relative;
    }

    .pod-enter-btn::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 3px;
        background: linear-gradient(90deg, #f77f00, #d62828, #6a4c93);
    }

    
        /* Vote Notification */
        .vote-notification {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 10, 10, 0.95);
            border: 2px solid rgba(241, 250, 238, 0.3);
            border-radius: 12px;
            padding: 25px 35px;
            z-index: 2500;
            display: none;
            min-width: 400px;
        }

        .vote-notification.show {
            display: block;
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from { transform: translateX(-50%) translateY(-20px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }

        .vote-title {
            font-family: 'VT323', monospace;
            font-size: 1.5rem;
            color: #f1faee;
            margin-bottom: 15px;
            text-align: center;
            letter-spacing: 1px;
        }

        .vote-options {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        }

        .vote-btn {
            flex: 1;
            padding: 12px;
            border: 2px solid rgba(241, 250, 238, 0.2);
            border-radius: 8px;
            background: transparent;
            color: #f1faee;
            font-family: 'VT323', monospace;
            font-size: 1.3rem;
            cursor: pointer;
            transition: all 0.3s;
            letter-spacing: 1px;
        }

        .vote-btn:hover {
            background: rgba(241, 250, 238, 0.1);
            border-color: rgba(241, 250, 238, 0.4);
        }

        .vote-btn.yes {
            border-color: rgba(45, 106, 79, 0.4);
        }

        .vote-btn.yes:hover {
            background: rgba(45, 106, 79, 0.2);
            border-color: #2d6a4f;
        }

        .vote-btn.no {
            border-color: rgba(230, 57, 70, 0.4);
        }

        .vote-btn.no:hover {
            background: rgba(230, 57, 70, 0.2);
            border-color: #e63946;
        }

        .vote-progress {
            text-align: center;
            font-size: 0.9rem;
            color: #888;
            margin-top: 10px;
        }

        .vote-bar {
            width: 100%;
            height: 4px;
            background: rgba(241, 250, 238, 0.1);
            border-radius: 2px;
            margin-top: 8px;
            overflow: hidden;
        }

        .vote-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #f77f00, #d62828);
            width: 0%;
            transition: width 0.3s;
        }

        .mode-indicator {
            font-family: 'VT323', monospace;
            letter-spacing: 1px;
        }

        
        /* MOBILE RESPONSIVE */
        @media (max-width: 768px) {
            .room-header {
                padding: 12px 16px;
                flex-direction: column;
                gap: 12px;
                align-items: flex-start;
            }
            
            .room-info {
                width: 100%;
            }
            
            .back-button {
                font-size: 1rem;
                padding: 6px 12px;
            }
            
            .room-title {
                font-size: 2rem;
            }
            
            .room-title span:first-child {
                font-size: 1.8rem;
            }
            
            .online-indicator {
                font-size: 0.85rem;
            }
            
            .main-layout {
                flex-direction: column;
                height: auto;
                min-height: calc(100vh - 80px);
            }
            
            .sidebar {
                width: 100%;
                max-width: 100%;
                border-right: none;
                border-bottom: 1px solid rgba(241, 250, 238, 0.1);
                max-height: 300px;
                overflow-y: auto;
            }
            
            .main-area {
                width: 100%;
                padding: 20px 16px;
                position: relative;
                z-index: 1; /* Creates proper stacking context for chat/music */
            }
            
            /* Avatar grid mobile */
            .avatars-grid {
                grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
                gap: 12px;
                padding: 16px;
            }
            
            .avatar-container {
                width: 60px;
                height: 120px;
            }
            
            .username {
                font-size: 0.7rem;
            }
            
            /* Chat mobile - RETRACTABLE */
            .chat-sidebar {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                height: 60px;
                max-height: 60px;
                transition: height 0.3s ease, max-height 0.3s ease;
                z-index: 200;
                border-radius: 12px 12px 0 0;
                background: rgba(10, 10, 10, 0.95);
            }
            
            .chat-sidebar.expanded {
                height: 400px;
                max-height: 400px;
                backdrop-filter: blur(10px);
            }
            
            /* Hide collapsed tabs when other is expanded */
            .music-control.hide-tab {
                display: none;
            }
            
            .chat-sidebar.hide-tab {
                display: none;
            }
            
            .chat-sidebar::before {
                content: 'üí¨ Chat';
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                height: 50px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-family: 'VT323', monospace;
                font-size: 1.2rem;
                background: rgba(241, 250, 238, 0.05);
                border-bottom: 1px solid rgba(241, 250, 238, 0.1);
                cursor: pointer;
                border-radius: 12px 12px 0 0;
                z-index: 1;
            }
            
            .chat-sidebar.expanded::before {
                content: '‚úï Close Chat';
                background: rgba(241, 250, 238, 0.08);
            }
            
            .chat-header,
            .chat-messages,
            .chat-input-container {
                opacity: 0;
                pointer-events: none;
                transition: opacity 0.3s ease;
            }
            
            .chat-sidebar.expanded .chat-header,
            .chat-sidebar.expanded .chat-messages,
            .chat-sidebar.expanded .chat-input-container {
                opacity: 1;
                pointer-events: auto;
            }
            
            .chat-messages {
                margin-top: 50px;
                height: calc(100% - 110px);
            }
            
            .message {
                padding: 12px;
                font-size: 0.9rem;
            }
            
            .chat-input {
                padding: 12px;
                font-size: 0.9rem;
            }
            
            /* Music player mobile - RETRACTABLE */
            .music-control {
                position: fixed;
                bottom: 60px;
                left: 0;
                right: 0;
                height: 60px;
                max-height: 60px;
                transition: height 0.3s ease, max-height 0.3s ease;
                z-index: 199;
                border-radius: 12px 12px 0 0;
                background: rgba(10, 10, 10, 0.95);
            }
            
            .music-control.expanded {
                height: 350px;
                max-height: 350px;
                backdrop-filter: blur(10px);
            }
            
            .music-control::before {
                content: 'üéµ Music';
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                height: 50px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-family: 'VT323', monospace;
                font-size: 1.2rem;
                background: rgba(241, 250, 238, 0.05);
                border-bottom: 1px solid rgba(241, 250, 238, 0.1);
                cursor: pointer;
                border-radius: 12px 12px 0 0;
                z-index: 1;
            }
            
            .music-control.expanded::before {
                content: '‚úï Close Music';
                background: rgba(241, 250, 238, 0.08);
            }
            
            .now-playing,
            .playback-controls,
            .progress-bar,
            .queue-preview {
                opacity: 0;
                pointer-events: none;
                transition: opacity 0.3s ease;
            }
            
            .music-control.expanded .now-playing,
            .music-control.expanded .playback-controls,
            .music-control.expanded .progress-bar,
            .music-control.expanded .queue-preview {
                opacity: 1;
                pointer-events: auto;
            }
            
            .now-playing {
                margin-top: 50px;
                flex-direction: column;
                gap: 12px;
                text-align: center;
            }
            
            .album-art {
                font-size: 2.5rem;
            }
            
            .track-title {
                font-size: 1.1rem;
            }
            
            .playback-controls {
                flex-wrap: wrap;
                gap: 8px;
            }
            
            .control-btn {
                font-size: 1.2rem;
                min-width: 44px;
                min-height: 44px;
            }
            
            /* Vote button mobile */
            .vote-section {
                padding: 12px 16px;
            }
            
            .vote-btn {
                font-size: 0.9rem;
                padding: 10px 20px;
                min-height: 44px;
            }
            
            /* Add track modal mobile */
            .modal-content {
                width: 95%;
                max-width: 95%;
                margin: 20px auto;
                padding: 24px 16px;
                max-height: 85vh;
                overflow-y: auto;
            }
            
            .modal-title {
                font-size: 1.8rem;
            }
            
            .upload-box {
                padding: 30px 20px;
                min-height: 120px;
            }
            
            .upload-icon {
                font-size: 2.5rem;
            }
            
            .queue-item {
                padding: 12px;
            }
            
            .close-modal {
                font-size: 1.5rem;
                width: 36px;
                height: 36px;
            }
        }
    </style>
</head>
<body>
    <div class="room-container">
        <div class="room-header">
            <div class="room-info">
                <a href="#" class="back-button" onclick="goToHub()">‚Üê hub</a>
                <h1 class="room-title" id="roomTitle">
                    <span id="roomIcon">üåô</span>
                    <span id="roomName">the sanctuary</span>
                </h1>
            </div>
            <div class="online-indicator">
                <span class="pulse-dot"></span>
                <span id="onlineCount">7 present</span>
            </div>
        </div>

        <div class="main-area">
            <div class="room-space" id="roomSpace">
                <div class="room-ambient">
                    <div class="ambient-orb orb-1"></div>
                    <div class="ambient-orb orb-2"></div>
                </div>
                <div class="avatars-layer" id="avatarsLayer"></div>
            </div>

            <div class="chat-sidebar">
                <div class="chat-header">
                    <div class="chat-title">room chat</div>
                    <div class="users-in-room" id="usersInRoom">0 people here</div>
                    <button id="wipeChatBtn" onclick="wipeChat()" style="display: none; padding: 4px 12px; background: rgba(214, 40, 40, 0.2); border: 1px solid #d62828; border-radius: 4px; color: #d62828; font-family: 'VT323', monospace; font-size: 0.9rem; cursor: pointer; margin-left: auto;" title="Delete all messages (admin)">wipe chat</button>
                </div>
                <div class="chat-messages" id="chatMessages"></div>
                <div class="chat-input-container">
                    <input type="text" class="chat-input" id="chatInput" placeholder="say something..." maxlength="500">
                </div>
            </div>
        </div>

        <div class="music-control">
            <div class="now-playing">
                <div class="album-art">üéµ</div>
                <div class="track-info">
                    <div class="mode-indicator" id="modeIndicator" style="font-size: 0.85rem; color: #7fc29b; margin-bottom: 5px;">
                        üåç shared queue
                    </div>
                    <div class="track-title" id="nowPlayingTitle">no track playing</div>
                    <div class="track-artist" id="nowPlayingArtist">upload or add a track</div>
                </div>
            </div>
            <div class="playback-controls">
                <button class="control-btn" id="modeToggleBtn" onclick="toggleQueueMode()" style="background: rgba(106, 76, 147, 0.2); color: #f1faee; font-weight: 500;">
                    üéß private pod
                </button>
                <button class="control-btn" onclick="previousTrack()">‚èÆ</button>
                <button class="control-btn" onclick="togglePlayback()" id="playBtn">‚ñ∂</button>
                <button class="control-btn" onclick="nextTrack()">‚è≠</button>
            </div>
            <button class="queue-btn" onclick="openQueue()">queue</button>
        </div>
    </div>

    <!-- Firebase SDKs -->
    <script>
        // Expose critical UI functions IMMEDIATELY (before module loads)
        // These need to be available for onclick handlers
        
        // Music queue state (available immediately)
        let audioPlayer = null;
        
        window.openQueue = function() {
            console.log('openQueue called');
            const modal = document.getElementById('queueModal');
            if (modal) {
                modal.style.display = 'flex';
                console.log('Modal opened');
            } else {
                console.error('Queue modal not found!');
            }
        };
        
        window.closeQueue = function() {
            const modal = document.getElementById('queueModal');
            if (modal) {
                modal.style.display = 'none';
            }
        };
        
        window.enterPod = function() {
            alert('Private pod: Your personal listening space (Firebase sync coming soon)');
            window.closeQueue();
        };
        
        // File upload handler
        // File upload and URL handlers are defined in the music module below
        
        // URL handler - defined in music module below
        
        // Extract YouTube video ID from various URL formats
        function extractYouTubeID(url) {
            const patterns = [
                /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\?\/]+)/,
                /youtube\.com\/watch\?.*v=([^&]+)/
            ];
            
            for (let pattern of patterns) {
                const match = url.match(pattern);
                if (match && match[1]) {
                    return match[1];
                }
            }
            return null;
        }
        
        // Switch to iframe-based player for YouTube/SoundCloud
        function switchToEmbedPlayer(track) {
            // Hide regular audio controls
            const musicControl = document.querySelector('.music-control');
            if (musicControl) {
                // Store original HTML to restore later
                if (!window.originalMusicControl) {
                    window.originalMusicControl = musicControl.innerHTML;
                }
            }
            
            // Create or update embed container
            let embedContainer = document.getElementById('embedPlayer');
            if (!embedContainer) {
                embedContainer = document.createElement('div');
                embedContainer.id = 'embedPlayer';
                embedContainer.style.cssText = `
                    position: fixed;
                    bottom: 0;
                    left: 0;
                    right: 0;
                    height: 120px;
                    background: rgba(10, 10, 10, 0.98);
                    border-top: 1px solid rgba(241, 250, 238, 0.2);
                    z-index: 2000;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    padding: 10px;
                `;
                document.body.appendChild(embedContainer);
            }
            
            // Clear and add iframe
            embedContainer.innerHTML = `
                <div style="width: 100%; max-width: 1200px; display: flex; align-items: center; gap: 20px;">
                    <div style="flex: 1;">
                        <iframe 
                            id="embedIframe"
                            src="${track.embedUrl}"
                            width="100%" 
                            height="100"
                            frameborder="0"
                            allow="autoplay; encrypted-media"
                            style="border-radius: 8px;"
                        ></iframe>
                    </div>
                    <button onclick="closeEmbedPlayer()" style="
                        padding: 10px 20px;
                        background: rgba(230, 57, 70, 0.2);
                        border: 1px solid #e63946;
                        border-radius: 6px;
                        color: #f1faee;
                        cursor: pointer;
                        font-family: 'VT323', monospace;
                        font-size: 1.2rem;
                    ">close player</button>
                </div>
            `;
            
            // Update now playing
            const titleEl = document.getElementById('nowPlayingTitle');
            const artistEl = document.getElementById('nowPlayingArtist');
            if (titleEl) titleEl.textContent = track.title;
            if (artistEl) artistEl.textContent = track.artist;
            
            console.log('Embed player created for:', track.type);
        }
        
        // Close embed player
        window.closeEmbedPlayer = function() {
            const embedContainer = document.getElementById('embedPlayer');
            if (embedContainer) {
                embedContainer.remove();
            }
            
            // Restore original controls
            const musicControl = document.querySelector('.music-control');
            if (musicControl && window.originalMusicControl) {
                musicControl.innerHTML = window.originalMusicControl;
            }
            
            console.log('Embed player closed');
        };
        
        // Add to queue UI
        function addToQueueUI(title, artist, time) {
            const queueList = document.getElementById('queueList');
            if (!queueList) {
                console.error('Queue list not found');
                return;
            }
            
            // Remove example track if it exists
            const exampleTrack = queueList.querySelector('.queue-item');
            if (exampleTrack && exampleTrack.querySelector('.queue-item-title').textContent === 'ambient waves') {
                exampleTrack.remove();
            }
            
            const item = document.createElement('div');
            item.className = 'queue-item';
            item.innerHTML = `
                <div class="queue-item-info">
                    <div class="queue-item-title">${title}</div>
                    <div class="queue-item-artist">${artist}</div>
                </div>
                <div class="queue-item-time">${time}</div>
            `;
            queueList.appendChild(item);
            
            console.log('Added to queue UI:', title);
        }
        
        // Placeholder music functions - will be replaced by module when it loads
        window.togglePlayback = function() {
            if (!audioPlayer) {
                audioPlayer = document.getElementById('audioPlayer');
            }
            
            if (!audioPlayer) {
                alert('Audio player not ready');
                return;
            }
            
            if (!audioPlayer.src) {
                alert('No track loaded. Upload a file first!');
                return;
            }
            
            const btn = document.getElementById('playBtn');
            
            if (audioPlayer.paused) {
                audioPlayer.play().then(() => {
                    if (btn) btn.textContent = '‚è∏';
                    console.log('Playing...');
                }).catch(e => {
                    console.error('Play error:', e);
                    alert('Could not play audio: ' + e.message);
                });
            } else {
                audioPlayer.pause();
                if (btn) btn.textContent = '‚ñ∂';
                console.log('Paused');
            }
        };
        
        window.toggleListeningMode = function() {
            alert('Mode toggle: Firebase needs to load first');
        };
        
        window.previousTrack = function() {
            alert('Previous track: Upload a track first');
        };
        
        window.nextTrack = function() {
            alert('Next track: Upload a track first');
        };
        
        window.goToHub = function() {
            window.location.href = 'hub.html';
        };
        
        window.castVote = function() {
            alert('Voting: Firebase needs to load first');
        };
        
        console.log('‚úì All UI functions exposed globally');
    </script>
    
    <script type="module">
        console.log('üöÄ ROOM.HTML SCRIPT STARTING...');
        
        // Import Firebase
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getAuth, onAuthStateChanged, setPersistence, browserLocalPersistence } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        import { getFirestore, doc, getDoc, setDoc, updateDoc, deleteDoc, collection, query, where, onSnapshot, addDoc, orderBy, limit, getDocs } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
        import { getStorage, ref, getDownloadURL, uploadBytes } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-storage.js';

        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCXFlGeJodOUVn-3bYocPhFRtzs9DBHEFA",
            authDomain: "earthtown-92993.firebaseapp.com",
            projectId: "earthtown-92993",
            storageBucket: "earthtown-92993.firebasestorage.app",
            messagingSenderId: "830730193161",
            appId: "1:830730193161:web:af18953dd80872b1396bd8",
            measurementId: "G-KC30SQWHEC"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const storage = getStorage(app);
        
        // Enable persistent login
        setPersistence(auth, browserLocalPersistence).catch(err => {
            console.error('Persistence error:', err);
        });
        
        console.log('‚úì Firebase initialized');
        console.log('Auth:', auth);
        console.log('DB:', db);
        console.log('Storage:', storage);

        // Get room name from URL
        const urlParams = new URLSearchParams(window.location.search);
        const roomName = urlParams.get('room') || 'sanctuary';
        
        // ============================================
        // ROOM PLAYLISTS CONFIG
        // ============================================
        const roomPlaylists = {
            sanctuary: [
                // Meditation playlist - add track info when ready
                // { title: "Track Title", artist: "Artist Name", url: "./track1.MP3" }
            ],
            studio: [
                // Alive & Well - EP by CLOUD5 & santos bluÀê
                { title: "Love or War", artist: "CLOUD5 & santos bluÀê", url: "./aw1.MP3" },
                { title: "13 Bricks", artist: "CLOUD5 & santos bluÀê", url: "./aw2.MP3" },
                { title: "Filet Mignon", artist: "CLOUD5 & santos bluÀê", url: "./aw3.MP3" },
                { title: "we were gonna call it alive n well (interlude)", artist: "CLOUD5 & santos bluÀê", url: "./aw4.MP3" },
                { title: "3", artist: "CLOUD5 & santos bluÀê", url: "./aw5.MP3" },
                { title: "Fluid, Go Stupid !", artist: "CLOUD5 & santos bluÀê", url: "./aw6.MP3" }
            ],
            supernaturvl: [
                // SUPERNATURVL EP - add your track titles here
                { title: "Track 1", artist: "Your Artist Name", url: "./sn1.MP3" },
                { title: "Track 2", artist: "Your Artist Name", url: "./sn2.MP3" },
                { title: "Track 3", artist: "Your Artist Name", url: "./sn3.MP3" },
                { title: "Track 4", artist: "Your Artist Name", url: "./sn4.MP3" }
            ],
            gathering: [] // Empty - users upload
        };

        // Room configurations
        const roomConfigs = {
            sanctuary: { 
                icon: 'üåô', 
                name: 'the sanctuary',
                uploadsAllowed: false,
                forceMode: null // 'solo' or 'room' or null for choice
            },
            studio: { 
                icon: 'üéôÔ∏è', 
                name: 'the studio',
                uploadsAllowed: false,
                forceMode: null, // User chooses on entry
                showModeModal: true // Show choice modal on entry
            },
            gathering: { 
                icon: 'üåç', 
                name: 'the gathering',
                uploadsAllowed: true,
                forceMode: null // User can toggle
            },
            supernaturvl: { 
                icon: 'üëÅÔ∏è', 
                name: 'SUPERNATURVL',
                uploadsAllowed: false,
                forceMode: 'solo' // Always solo mode
            }
        };
        
        // Update room title and icon
        const roomConfig = roomConfigs[roomName] || roomConfigs.sanctuary;
        document.getElementById('roomIcon').textContent = roomConfig.icon;
        document.getElementById('roomName').textContent = roomConfig.name;
        
        // Current user
        let currentUser = null;
        let currentUserData = null;
        let usersInRoom = [];
        let currentDetailPopup = null;
        let presenceUnsubscribe = null;
        let messagesUnsubscribe = null;

        // Check authentication and initialize
        onAuthStateChanged(auth, async (user) => {
            console.log('üîê Auth state changed, user:', user ? user.uid : 'NO USER');
            if (user) {
                currentUser = user;
                console.log('Loading user data for:', user.uid);
                await loadUserData(user.uid);
                console.log('User data loaded:', currentUserData);
                console.log('Joining room:', roomName);
                await joinRoom();
                console.log('Room joined, setting up listeners');
                setupEventListeners();
                
                // Initialize room-specific features
                loadRoomPlaylist();
                configureRoomControls();
                showModeModal();
                loadPodFromStorage();
                renderPodQueue();
                
                // Listen for shared queue updates from Firebase
                listenToRoomQueue();
                
                console.log('‚úì Setup complete');
                
                // Mobile: Add toggle functionality for chat and music player
                if (window.innerWidth <= 768) {
                    const chatSidebar = document.querySelector('.chat-sidebar');
                    const musicControl = document.querySelector('.music-control');
                    
                    if (chatSidebar) {
                        chatSidebar.addEventListener('click', function(e) {
                            // Only toggle if clicking the header area (top 50px)
                            const rect = chatSidebar.getBoundingClientRect();
                            const clickY = e.clientY - rect.top;
                            if (clickY <= 50) {
                                chatSidebar.classList.toggle('expanded');
                                // Auto-collapse music when chat opens
                                if (chatSidebar.classList.contains('expanded') && musicControl) {
                                    musicControl.classList.remove('expanded');
                                    musicControl.classList.add('hide-tab'); // Hide music tab
                                } else if (musicControl) {
                                    musicControl.classList.remove('hide-tab'); // Show music tab
                                }
                            }
                        });
                    }
                    
                    if (musicControl) {
                        musicControl.addEventListener('click', function(e) {
                            // Only toggle if clicking the header area (top 50px)
                            const rect = musicControl.getBoundingClientRect();
                            const clickY = e.clientY - rect.top;
                            if (clickY <= 50) {
                                musicControl.classList.toggle('expanded');
                                // Auto-collapse chat when music opens (but keep chat tab visible)
                                if (musicControl.classList.contains('expanded') && chatSidebar) {
                                    chatSidebar.classList.remove('expanded');
                                    // Don't hide chat tab - it stays visible
                                }
                            }
                        });
                    }
                }
            } else {
                console.log('No user, redirecting to index');
                window.location.href = 'index.html';
            }
        });

        // Cleanup on page leave
        window.addEventListener('beforeunload', async () => {
            console.log('üö™ User leaving, cleaning up...');
            
            // Stop heartbeat
            if (presenceInterval) {
                clearInterval(presenceInterval);
            }
            
            // Try to delete presence immediately (best effort)
            if (currentUser) {
                try {
                    const presenceDocRef = doc(db, 'rooms', roomName, 'presence', currentUser.uid);
                    await deleteDoc(presenceDocRef);
                    console.log('‚úì Presence deleted');
                } catch (error) {
                    console.log('Presence cleanup failed (fallback will handle it)');
                }
            }
        });

        async function loadUserData(uid) {
            try {
                const userDoc = await getDoc(doc(db, 'users', uid));
                if (userDoc.exists()) {
                    currentUserData = { id: uid, ...userDoc.data(), x: 300, y: 250 };
                    
                    // Show wipe chat button for admins
                    if (currentUserData.isAdmin === true) {
                        const wipeChatBtn = document.getElementById('wipeChatBtn');
                        if (wipeChatBtn) wipeChatBtn.style.display = 'block';
                    }
                }
            } catch (error) {
                console.error('Error loading user data:', error);
            }
        }

        async function joinRoom() {
            try {
                // Update user's current room
                await updateDoc(doc(db, 'users', currentUser.uid), {
                    currentRoom: roomName,
                    lastSeen: new Date().toISOString()
                });

                // Create or update user's presence in room
                const presenceDocRef = doc(db, 'rooms', roomName, 'presence', currentUser.uid);
                await setDoc(presenceDocRef, {
                    userId: currentUser.uid,
                    username: currentUserData.username,
                    archetype: currentUserData.archetype,
                    characterImage: currentUserData.characterImage,
                    x: currentUserData.x,
                    y: currentUserData.y,
                    joinedAt: new Date().toISOString(),
                    lastSeen: new Date().toISOString() // NEW - for presence tracking
                });

                // Start presence heartbeat (update lastSeen every 30 seconds)
                startPresenceHeartbeat();

                // Listen to room presence
                listenToRoomPresence();
                
                // Listen to room messages
                listenToRoomMessages();

            } catch (error) {
                console.error('Error joining room:', error);
            }
        }

        // Presence heartbeat - update lastSeen every 30 seconds
        let presenceInterval = null;
        
        function startPresenceHeartbeat() {
            // Clear any existing interval
            if (presenceInterval) clearInterval(presenceInterval);
            
            presenceInterval = setInterval(async () => {
                if (!currentUser) {
                    clearInterval(presenceInterval);
                    return;
                }
                
                try {
                    const presenceDocRef = doc(db, 'rooms', roomName, 'presence', currentUser.uid);
                    await updateDoc(presenceDocRef, {
                        lastSeen: new Date().toISOString()
                    });
                    console.log('üíì Presence heartbeat updated');
                } catch (error) {
                    console.log('Presence update failed (user may have left)');
                }
            }, 30000); // Every 30 seconds
            
            console.log('‚úì Presence heartbeat started');
        }

        function listenToRoomPresence() {
            console.log('üë• Setting up room presence listener for room:', roomName);
            const presenceRef = collection(db, 'rooms', roomName, 'presence');
            
            presenceUnsubscribe = onSnapshot(presenceRef, (snapshot) => {
                console.log('üì° Presence snapshot received, size:', snapshot.size);
                usersInRoom = [];
                snapshot.forEach((docSnapshot) => {
                    console.log('Processing user:', docSnapshot.id, docSnapshot.data());
                    const userData = docSnapshot.data();
                    
                    // Check if presence is stale and clean it up
                    const lastSeen = userData.lastSeen;
                    if (lastSeen) {
                        const timeSince = Date.now() - new Date(lastSeen).getTime();
                        if (timeSince > 120000) { // 2 minutes
                            // Delete stale presence doc
                            console.log('üßπ Deleting stale presence for:', docSnapshot.id);
                            deleteDoc(docSnapshot.ref).catch(err => console.log('Failed to delete stale presence'));
                            return; // Don't add to usersInRoom
                        }
                    } else {
                        // No lastSeen field = old doc from before this feature, clean it up
                        console.log('üßπ Deleting old presence (no lastSeen) for:', docSnapshot.id);
                        deleteDoc(docSnapshot.ref).catch(err => console.log('Failed to delete old presence'));
                        return; // Don't add to usersInRoom
                    }
                    
                    if (docSnapshot.id !== currentUser.uid) {
                        usersInRoom.push({
                            id: docSnapshot.id,
                            ...userData
                        });
                    } else {
                        // Update currentUserData from Firebase but don't re-render (prevents flash)
                        if (!isDraggingGlobal) {
                            currentUserData.x = userData.x;
                            currentUserData.y = userData.y;
                        }
                    }
                });
                
                console.log('About to call renderAvatars, usersInRoom:', usersInRoom);
                renderAvatars();
                updateOnlineCount();
            });
            console.log('‚úì Presence listener attached');
        }

        let isDraggingGlobal = false;

        function listenToRoomMessages() {
            const messagesRef = collection(db, 'rooms', roomName, 'messages');
            const messagesQuery = query(messagesRef, orderBy('timestamp', 'desc'), limit(50));
            
            messagesUnsubscribe = onSnapshot(messagesQuery, (snapshot) => {
                const container = document.getElementById('chatMessages');
                container.innerHTML = '';
                
                const messages = [];
                snapshot.forEach((doc) => {
                    messages.push({ id: doc.id, ...doc.data() });
                });
                
                // Reverse to show oldest first
                messages.reverse().forEach(msg => {
                    const messageEl = createMessageElement(msg);
                    container.appendChild(messageEl);
                });
                
                container.scrollTop = container.scrollHeight;
            });
        }

        function updateOnlineCount() {
            const total = usersInRoom.length + 1; // +1 for current user
            document.getElementById('onlineCount').textContent = `${total} present`;
            document.getElementById('usersInRoom').textContent = `${total} people here`;
        }

        function renderAvatars() {
            console.log('=== renderAvatars called ===');
            console.log('currentUserData:', currentUserData);
            console.log('usersInRoom:', usersInRoom);
            
            if (!currentUserData) {
                console.error('‚ùå currentUserData is null, cannot render avatars');
                return;
            }
            
            const container = document.getElementById('avatarsLayer');
            console.log('avatarsLayer container:', container);
            
            if (!container) {
                console.error('‚ùå avatarsLayer container not found!');
                return;
            }
            
            // Only create current user's avatar if it doesn't exist yet
            const existingCurrentAvatar = document.getElementById('avatar-' + currentUser.uid);
            console.log('Existing current user avatar:', existingCurrentAvatar);
            
            if (!existingCurrentAvatar) {
                console.log('Creating current user avatar with data:', {
                    id: currentUser.uid,
                    username: currentUserData.username,
                    x: currentUserData.x,
                    y: currentUserData.y,
                    archetype: currentUserData.archetype,
                    characterImage: currentUserData.characterImage
                });
                
                const currentAvatar = createAvatarElement(currentUserData, true);
                console.log('Created avatar element:', currentAvatar);
                container.appendChild(currentAvatar);
                console.log('‚úì Current user avatar appended to container');
            } else {
                console.log('Current user avatar already exists');
            }

            // Remove avatars that are no longer in the room
            const existingAvatars = container.querySelectorAll('.avatar:not(.current-user)');
            console.log('Existing other avatars:', existingAvatars.length);
            existingAvatars.forEach(avatarEl => {
                const userId = avatarEl.dataset.userId;
                if (!usersInRoom.find(u => u.id === userId)) {
                    console.log('Removing avatar for user who left:', userId);
                    avatarEl.remove();
                }
            });

            // Update or create other users' avatars
            console.log('Processing', usersInRoom.length, 'other users');
            usersInRoom.forEach(user => {
                let avatar = document.getElementById('avatar-' + user.id);
                if (avatar) {
                    // Update position
                    console.log('Updating position for', user.username, 'to', user.x, user.y);
                    avatar.style.left = user.x + 'px';
                    avatar.style.top = user.y + 'px';
                } else {
                    // Create new avatar
                    console.log('Creating new avatar for', user.username);
                    avatar = createAvatarElement(user, false);
                    container.appendChild(avatar);
                }
            });
            
            console.log('=== renderAvatars complete ===');
            console.log('Total avatars in container:', container.querySelectorAll('.avatar').length);
        }

        function createAvatarElement(user, isCurrentUser) {
            console.log('createAvatarElement called:', {
                userId: user.id || currentUser.uid,
                username: user.username,
                isCurrentUser: isCurrentUser,
                x: user.x,
                y: user.y,
                characterImage: user.characterImage
            });
            
            const avatar = document.createElement('div');
            avatar.className = 'avatar' + (isCurrentUser ? ' current-user' : '');
            avatar.style.left = user.x + 'px';
            avatar.style.top = user.y + 'px';
            avatar.id = 'avatar-' + (user.id || currentUser.uid);
            avatar.dataset.userId = user.id || currentUser.uid;

            console.log('Avatar element created with styles:', {
                left: avatar.style.left,
                top: avatar.style.top,
                id: avatar.id
            });

            avatar.innerHTML = `
                <div class="avatar-image" id="avatar-img-${user.id || currentUser.uid}"></div>
                <div class="avatar-name archetype-${user.archetype}">${user.username}</div>
            `;

            console.log('Avatar HTML set, innerHTML length:', avatar.innerHTML.length);

            // Load character image if available
            if (user.characterImage) {
                console.log('Character image path found:', user.characterImage);
                loadCharacterImage(user.id || currentUser.uid, user.characterImage);
            } else {
                console.log('No character image for user');
            }

            if (!isCurrentUser) {
                avatar.addEventListener('click', (e) => {
                    e.stopPropagation();
                    showAvatarDetail(user, e.clientX, e.clientY);
                });
            }

            console.log('‚úì Avatar element ready to return');
            return avatar;
        }

        async function loadCharacterImage(userId, characterImagePath) {
            console.log('loadCharacterImage called for:', userId, characterImagePath);
            try {
                if (!characterImagePath) {
                    console.log('No character image path provided');
                    return;
                }
                
                const charRef = ref(storage, characterImagePath);
                console.log('Getting download URL for:', characterImagePath);
                const charURL = await getDownloadURL(charRef);
                console.log('Got URL:', charURL);
                
                const avatarImgContainer = document.getElementById(`avatar-img-${userId}`);
                console.log('Avatar container:', avatarImgContainer);
                
                if (avatarImgContainer) {
                    avatarImgContainer.innerHTML = `<img src="${charURL}" draggable="false" style="width: 150px; height: 150px; object-fit: contain; image-rendering: pixelated; background: none; pointer-events: none; user-select: none;">`;
                    console.log('‚úì Character image loaded for', userId);
                } else {
                    console.error('Avatar container not found for', userId);
                }
            } catch (error) {
                console.error('Error loading character image for', userId, error);
                // Fallback: show colored placeholder
                const avatarImgContainer = document.getElementById(`avatar-img-${userId}`);
                if (avatarImgContainer) {
                    avatarImgContainer.innerHTML = `<div style="width: 150px; height: 150px; background: rgba(241, 250, 238, 0.1); border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 3rem;">üë§</div>`;
                    console.log('‚úì Fallback placeholder shown for', userId);
                }
            }
        }

        function getArchetypeColor(archetype) {
            const colors = {
                hero: 'linear-gradient(135deg, #f1faee, #c79564)',
                sage: 'linear-gradient(135deg, #9b87c7, #8b77b7)',
                explorer: 'linear-gradient(135deg, #7fc29b, #6fb28b)',
                rebel: 'linear-gradient(135deg, #c77a7a, #b76a6a)',
                magician: 'linear-gradient(135deg, #c79bd9, #b78bc9)',
                lover: 'linear-gradient(135deg, #d99ba3, #c98b93)',
                jester: 'linear-gradient(135deg, #f0c77a, #e0b76a)',
                innocent: 'linear-gradient(135deg, #b5d4e8, #a5c4d8)',
                caregiver: 'linear-gradient(135deg, #a8d4a8, #98c498)',
                ruler: 'linear-gradient(135deg, #f1faee, #c49564)',
                creator: 'linear-gradient(135deg, #c7a77a, #b7976a)',
                everyman: 'linear-gradient(135deg, #a8a8a8, #989898)'
            };
            return colors[archetype] || colors.everyman;
        }

        function showAvatarDetail(user, x, y) {
            if (currentDetailPopup) {
                currentDetailPopup.remove();
            }

            const popup = document.createElement('div');
            popup.className = 'avatar-detail';
            
            const popupWidth = 250;
            const popupHeight = 150;
            let left = x + 20;
            let top = y - 75;

            if (left + popupWidth > window.innerWidth) {
                left = x - popupWidth - 20;
            }
            if (top + popupHeight > window.innerHeight) {
                top = window.innerHeight - popupHeight - 20;
            }
            if (top < 0) top = 20;

            popup.style.left = left + 'px';
            popup.style.top = top + 'px';

            const placeholderColor = getArchetypeColor(user.archetype);
            
            popup.innerHTML = `
                <div class="detail-close">√ó</div>
                <div class="detail-header">
                    <div class="detail-avatar" id="detail-avatar-${user.id}">
                        <div style="width: 70px; height: 70px; background: ${placeholderColor}; border-radius: 6px;"></div>
                    </div>
                    <div class="detail-info">
                        <div class="detail-username archetype-${user.archetype}">${user.username}</div>
                        <div class="detail-archetype archetype-${user.archetype}">${user.archetype}</div>
                    </div>
                </div>
                <div class="detail-gallery-links" id="gallery-links-${user.id}" style="margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(241, 250, 238, 0.1);">
                    <div style="font-size: 0.9rem; color: #888; margin-bottom: 8px;">loading gallery...</div>
                </div>
            `;

            document.body.appendChild(popup);
            currentDetailPopup = popup;

            // Load gallery links
            loadUserGalleryLinks(user.id || currentUser.uid);

            // Load character image for detail view
            if (user.characterImage) {
                loadDetailCharacterImage(user.id, user.characterImage);
            }

            popup.querySelector('.detail-close').addEventListener('click', () => {
                popup.remove();
                currentDetailPopup = null;
            });

            setTimeout(() => {
                document.addEventListener('click', closePopupOnOutsideClick);
            }, 10);
        }

        async function loadDetailCharacterImage(userId, characterImagePath) {
            try {
                const charRef = ref(storage, characterImagePath);
                const charURL = await getDownloadURL(charRef);
                
                const detailAvatarContainer = document.getElementById(`detail-avatar-${userId}`);
                if (detailAvatarContainer) {
                    detailAvatarContainer.innerHTML = `<img src="${charURL}" style="width: 70px; height: 70px; object-fit: contain; image-rendering: pixelated;">`;
                }
            } catch (error) {
                console.log('Could not load detail character image');
            }
        }

        async function loadUserGalleryLinks(userId) {
            try {
                // Count approved items by type
                const galleryQuery = query(
                    collection(db, 'gallery'),
                    where('userId', '==', userId),
                    where('status', '==', 'approved')
                );

                const snapshot = await getDocs(galleryQuery);
                const counts = { music: 0, video: 0, art: 0 };
                
                snapshot.forEach(doc => {
                    const type = doc.data().type;
                    if (counts.hasOwnProperty(type)) {
                        counts[type]++;
                    }
                });

                const linksContainer = document.getElementById(`gallery-links-${userId}`);
                if (!linksContainer) return;

                const totalWorks = counts.music + counts.video + counts.art;

                if (totalWorks === 0) {
                    linksContainer.innerHTML = ''; // Empty, no message needed
                    return;
                }

                let linksHTML = '<div style="font-size: 0.9rem; color: #888; margin-bottom: 8px;">gallery:</div>';
                linksHTML += '<div style="display: flex; gap: 8px; flex-wrap: wrap;">';

                if (counts.music > 0) {
                    linksHTML += `<a href="user-gallery.html?user=${userId}&type=music" target="_blank" style="padding: 4px 10px; background: rgba(241, 250, 238, 0.05); border: 1px solid rgba(241, 250, 238, 0.2); border-radius: 4px; color: #f1faee; text-decoration: none; font-size: 0.85rem;">üéµ ${counts.music}</a>`;
                }
                if (counts.video > 0) {
                    linksHTML += `<a href="user-gallery.html?user=${userId}&type=video" target="_blank" style="padding: 4px 10px; background: rgba(241, 250, 238, 0.05); border: 1px solid rgba(241, 250, 238, 0.2); border-radius: 4px; color: #f1faee; text-decoration: none; font-size: 0.85rem;">üé¨ ${counts.video}</a>`;
                }
                if (counts.art > 0) {
                    linksHTML += `<a href="user-gallery.html?user=${userId}&type=art" target="_blank" style="padding: 4px 10px; background: rgba(241, 250, 238, 0.05); border: 1px solid rgba(241, 250, 238, 0.2); border-radius: 4px; color: #f1faee; text-decoration: none; font-size: 0.85rem;">üñºÔ∏è ${counts.art}</a>`;
                }

                linksHTML += '</div>';
                linksContainer.innerHTML = linksHTML;

            } catch (error) {
                console.error('Error loading gallery links:', error);
                const linksContainer = document.getElementById(`gallery-links-${userId}`);
                if (linksContainer) {
                    linksContainer.innerHTML = '<div style="font-size: 0.85rem; color: #666;">gallery unavailable</div>';
                }
            }
        }

        function closePopupOnOutsideClick(e) {
            if (currentDetailPopup && !currentDetailPopup.contains(e.target)) {
                currentDetailPopup.remove();
                currentDetailPopup = null;
                document.removeEventListener('click', closePopupOnOutsideClick);
            }
        }

        function renderMessages() {
            const container = document.getElementById('chatMessages');
            container.innerHTML = '';

            messages.forEach(msg => {
                const messageEl = createMessageElement(msg);
                container.appendChild(messageEl);
            });

            container.scrollTop = container.scrollHeight;
        }

        function createMessageElement(msg) {
            const placeholderColor = getArchetypeColor(msg.archetype);
            
            // Format timestamp
            const time = msg.timestamp ? new Date(msg.timestamp).toLocaleTimeString('en-US', { 
                hour: 'numeric', 
                minute: '2-digit' 
            }) : '';
            
            const msgId = `msg-${Date.now()}-${Math.random()}`;
            
            // Check if current user can delete (own message) or is admin
            const isOwnMessage = currentUser && msg.userId === currentUser.uid;
            const isAdmin = currentUserData && currentUserData.isAdmin === true;
            
            // Build delete buttons
            let deleteButtons = '';
            if (isOwnMessage || isAdmin) {
                deleteButtons = `<button onclick="deleteMessage('${msg.id}', false)" style="background: none; border: none; color: #d62828; cursor: pointer; font-size: 0.85rem; padding: 0 5px; opacity: 0.6; transition: opacity 0.2s;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.6'" title="Delete (shows deleted)">delete</button>`;
            }
            if (isAdmin) {
                deleteButtons += `<button onclick="deleteMessage('${msg.id}', true)" style="background: none; border: none; color: #f77f00; cursor: pointer; font-size: 0.85rem; padding: 0 5px; opacity: 0.6; transition: opacity 0.2s; margin-left: 5px;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.6'" title="Remove (no trace)">remove</button>`;
            }
            
            const div = document.createElement('div');
            div.className = 'message';
            
            // Check if message is deleted
            if (msg.deleted) {
                div.innerHTML = `
                    <div class="message-avatar" style="background: rgba(214, 40, 40, 0.2);"></div>
                    <div class="message-content">
                        <div class="message-header">
                            <span class="message-author" style="color: #888;">[deleted]</span>
                            <span class="message-time">${time}</span>
                        </div>
                        <div class="message-text" style="color: #666; font-style: italic;">[message deleted]</div>
                    </div>
                `;
            } else {
                div.innerHTML = `
                    <div class="message-avatar" id="${msgId}" style="background: ${placeholderColor};"></div>
                    <div class="message-content">
                        <div class="message-header">
                            <span class="message-author archetype-${msg.archetype}">${msg.username}</span>
                            <span class="message-time">${time}</span>
                            ${deleteButtons}
                        </div>
                        <div class="message-text">${msg.text}</div>
                    </div>
                `;
                
                // Load character image for message
                if (msg.characterImage) {
                    loadMessageCharacterImage(msgId, msg.characterImage);
                }
            }
            
            return div;
        }

        async function loadMessageCharacterImage(msgId, characterImagePath) {
            try {
                const charRef = ref(storage, characterImagePath);
                const charURL = await getDownloadURL(charRef);
                
                const msgAvatar = document.getElementById(msgId);
                if (msgAvatar) {
                    msgAvatar.style.background = 'none';
                    msgAvatar.innerHTML = `<img src="${charURL}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 6px; image-rendering: pixelated;">`;
                }
            } catch (error) {
                console.log('Could not load message character image');
            }
        }

        // Delete message function
        window.deleteMessage = async function(messageId, removeCompletely) {
            if (!currentUser) return;
            
            const isAdmin = currentUserData && currentUserData.isAdmin === true;
            
            // Confirm action
            const action = removeCompletely ? 'remove' : 'delete';
            if (!confirm(`${action.charAt(0).toUpperCase() + action.slice(1)} this message?`)) {
                return;
            }
            
            try {
                if (removeCompletely && isAdmin) {
                    // Admin remove: delete completely (no trace)
                    await deleteDoc(doc(db, 'rooms', roomName, 'messages', messageId));
                    console.log('Message removed completely');
                } else {
                    // Regular delete: mark as deleted (shows placeholder)
                    await updateDoc(doc(db, 'rooms', roomName, 'messages', messageId), {
                        deleted: true,
                        text: '[message deleted]',
                        username: '[deleted]'
                    });
                    console.log('Message marked as deleted');
                }
            } catch (error) {
                console.error('Error deleting message:', error);
                console.error('Error code:', error.code);
                console.error('Error message:', error.message);
                alert(`Failed to delete message: ${error.message}`);
            }
        };

        // Wipe chat function (admin only)
        window.wipeChat = async function() {
            if (!currentUser || !currentUserData || !currentUserData.isAdmin) {
                alert('Admin only');
                return;
            }
            
            if (!confirm('WIPE ALL MESSAGES in this room? This cannot be undone!')) {
                return;
            }
            
            try {
                const messagesRef = collection(db, 'rooms', roomName, 'messages');
                const snapshot = await getDocs(messagesRef);
                
                const deletePromises = [];
                snapshot.forEach(doc => {
                    deletePromises.push(deleteDoc(doc.ref));
                });
                
                await Promise.all(deletePromises);
                alert(`Wiped ${deletePromises.length} messages`);
                console.log('Chat wiped');
            } catch (error) {
                console.error('Error wiping chat:', error);
                console.error('Error code:', error.code);
                console.error('Error message:', error.message);
                alert(`Failed to wipe chat: ${error.message}`);
            }
        };

        function setupEventListeners() {
            // Drag to move avatar (MOUSE + TOUCH)
            let dragStartX, dragStartY, avatarStartX, avatarStartY;
            let hasMoved = false;

            const roomSpace = document.getElementById('roomSpace');

            // MOUSE EVENTS
            roomSpace.addEventListener('mousedown', (e) => {
                const avatar = e.target.closest('.avatar.current-user');
                if (avatar) {
                    isDraggingGlobal = true;
                    hasMoved = false;
                    dragStartX = e.clientX;
                    dragStartY = e.clientY;
                    avatarStartX = currentUserData.x;
                    avatarStartY = currentUserData.y;
                }
            });

            document.addEventListener('mousemove', async (e) => {
                if (isDraggingGlobal && currentUserData) {
                    const deltaX = e.clientX - dragStartX;
                    const deltaY = e.clientY - dragStartY;
                    
                    // Mark as moved if dragged more than 5px
                    if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
                        hasMoved = true;
                    }

                    const rect = roomSpace.getBoundingClientRect();
                    currentUserData.x = Math.max(0, Math.min(avatarStartX + deltaX, rect.width - 150));
                    currentUserData.y = Math.max(0, Math.min(avatarStartY + deltaY, rect.height - 190));

                    const avatar = document.getElementById('avatar-' + currentUser.uid);
                    if (avatar) {
                        avatar.style.left = currentUserData.x + 'px';
                        avatar.style.top = currentUserData.y + 'px';
                    }
                }
            });

            document.addEventListener('mouseup', async (e) => {
                if (isDraggingGlobal) {
                    isDraggingGlobal = false;

                    // Only show popup if didn't move (was a click)
                    if (!hasMoved) {
                        const avatar = e.target.closest('.avatar.current-user');
                        if (avatar) {
                            showAvatarDetail(currentUserData, e.clientX, e.clientY);
                        }
                    }

                    // Update position in Firebase when drag ends (if moved)
                    if (hasMoved) {
                        try {
                            await updateDoc(
                                doc(db, 'rooms', roomName, 'presence', currentUser.uid),
                                {
                                    x: currentUserData.x,
                                    y: currentUserData.y
                                }
                            );
                        } catch (error) {
                            console.error('Error updating position:', error);
                        }
                    }
                }
            });

            // TOUCH EVENTS (for mobile)
            roomSpace.addEventListener('touchstart', (e) => {
                const avatar = e.target.closest('.avatar.current-user');
                if (avatar) {
                    isDraggingGlobal = true;
                    hasMoved = false;
                    const touch = e.touches[0];
                    dragStartX = touch.clientX;
                    dragStartY = touch.clientY;
                    avatarStartX = currentUserData.x;
                    avatarStartY = currentUserData.y;
                    e.preventDefault(); // Prevent scrolling while dragging
                }
            }, { passive: false });

            document.addEventListener('touchmove', async (e) => {
                if (isDraggingGlobal && currentUserData) {
                    const touch = e.touches[0];
                    const deltaX = touch.clientX - dragStartX;
                    const deltaY = touch.clientY - dragStartY;
                    
                    // Mark as moved if dragged more than 5px
                    if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
                        hasMoved = true;
                    }

                    const rect = roomSpace.getBoundingClientRect();
                    currentUserData.x = Math.max(0, Math.min(avatarStartX + deltaX, rect.width - 150));
                    currentUserData.y = Math.max(0, Math.min(avatarStartY + deltaY, rect.height - 190));

                    const avatar = document.getElementById('avatar-' + currentUser.uid);
                    if (avatar) {
                        avatar.style.left = currentUserData.x + 'px';
                        avatar.style.top = currentUserData.y + 'px';
                    }
                    
                    e.preventDefault(); // Prevent scrolling
                }
            }, { passive: false });

            document.addEventListener('touchend', async (e) => {
                if (isDraggingGlobal) {
                    isDraggingGlobal = false;

                    // Only show popup if didn't move (was a tap)
                    if (!hasMoved) {
                        const avatar = e.target.closest('.avatar.current-user');
                        if (avatar) {
                            const touch = e.changedTouches[0];
                            showAvatarDetail(currentUserData, touch.clientX, touch.clientY);
                        }
                    }

                    // Update position in Firebase when drag ends (if moved)
                    if (hasMoved) {
                        try {
                            await updateDoc(
                                doc(db, 'rooms', roomName, 'presence', currentUser.uid),
                                {
                                    x: currentUserData.x,
                                    y: currentUserData.y
                                }
                            );
                        } catch (error) {
                            console.error('Error updating position:', error);
                        }
                    }
                }
            });

            const chatInput = document.getElementById('chatInput');
            chatInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && chatInput.value.trim()) {
                    sendMessage(chatInput.value.trim());
                    chatInput.value = '';
                }
            });
        }

        async function sendMessage(text) {
            if (!currentUserData) return;

            try {
                await addDoc(
                    collection(db, 'rooms', roomName, 'messages'),
                    {
                        userId: currentUser.uid,
                        username: currentUserData.username,
                        archetype: currentUserData.archetype,
                        characterImage: currentUserData.characterImage,
                        text: text,
                        timestamp: new Date().toISOString()
                    }
                );
            } catch (error) {
                console.error('Error sending message:', error);
            }
        }

        function togglePlay() {
            isPlaying = !isPlaying;
            document.getElementById('playBtn').textContent = isPlaying ? '‚è∏' : '‚ñ∂';
        }

        function openQueue() {
            document.getElementById('queueModal').style.display = 'flex';
        }
        
        function closeQueue() {
            document.getElementById('queueModal').style.display = 'none';
        }
        
        function enterPod() {
            alert('Private pod: Your personal listening space (Firebase sync coming soon)');
            closeQueue();
        }

        async function goToHub() {
            window.location.href = 'hub.html';
        }

        // Make functions available globally for onclick handlers
        window.openQueue = openQueue;
        window.closeQueue = closeQueue;
        window.enterPod = enterPod;
        window.goToHub = goToHub;
    
        
        // ============================================
        // MUSIC PLAYER WITH ROOM/SOLO MODES
        // ============================================

        // Initialize audio player
        if (!audioPlayer) {
            audioPlayer = document.getElementById('audioPlayer');
        }

        // Player State
        let roomQueue = []; // Shared room queue
        let currentTrackIndex = 0;
        let isPlaying = false;
        
        // ============================================
        // PRIVATE POD STATE
        // ============================================
        let podQueue = []; // Private pod queue
        let podTrackIndex = 0;
        let podLoopMode = false;
        let inPodMode = false;
        let lastShareTime = 0;
        let bulkPushInterval = null;
        let bulkPushCount = 0;
        let bulkPushTotal = 0;

        // LocalStorage functions
        function savePodToStorage() {
            try {
                // Don't save local uploads (too big), only save pre-loaded/URL tracks
                const tracksToSave = podQueue.filter(t => !t.isLocalUpload);
                const data = JSON.stringify(tracksToSave);
                localStorage.setItem(`earthtown_pod_${roomName}`, data);
                console.log('‚úì Pod saved to localStorage (' + tracksToSave.length + ' tracks)');
            } catch (e) {
                console.error('Failed to save pod:', e);
            }
        }

        function loadPodFromStorage() {
            try {
                const saved = localStorage.getItem(`earthtown_pod_${roomName}`);
                if (saved) {
                    podQueue = JSON.parse(saved);
                    console.log('‚úì Loaded', podQueue.length, 'tracks from localStorage');
                    renderPodQueue();
                }
            } catch (e) {
                console.error('Failed to load pod:', e);
                podQueue = [];
            }
        }

        // Load pre-configured playlist for this room
        function loadRoomPlaylist() {
            const playlist = roomPlaylists[roomName] || [];
            if (playlist.length > 0) {
                console.log(`Loading ${playlist.length} tracks for ${roomName}`);
                roomQueue = [...playlist];
                soloQueue = [...playlist];
                
                // Update queue UI
                playlist.forEach(track => {
                    addToQueueUI(track.title, track.artist, track.duration || '0:00');
                });
                
                console.log('‚úì Room playlist loaded');
            }
        }

        // Hide/show upload controls based on room config
        function configureRoomControls() {
            const fileUploadBtn = document.querySelector('.upload-box');
            const urlInputSection = document.querySelector('.url-input-section');
            
            if (!roomConfig.uploadsAllowed) {
                // Hide upload controls
                if (fileUploadBtn) fileUploadBtn.style.display = 'none';
                if (urlInputSection) urlInputSection.style.display = 'none';
                console.log('‚úì Uploads disabled for', roomName);
            }
            
            // For SUPERNATURVL - hide mode toggle button
            if (roomConfig.forceMode === 'solo') {
                const modeToggleBtn = document.getElementById('modeToggleBtn');
                if (modeToggleBtn) modeToggleBtn.style.display = 'none';
                console.log('‚úì Solo mode forced for', roomName);
            }
        }

        // Show mode selection modal for studio
        function showModeModal() {
            if (roomConfig.showModeModal) {
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed;
                    top: 0; left: 0; right: 0; bottom: 0;
                    background: rgba(0,0,0,0.9);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                `;
                modal.innerHTML = `
                    <div style="background: #0a0a0a; border: 2px solid #f1faee; border-radius: 12px; padding: 40px; max-width: 500px; text-align: center;">
                        <h2 style="font-family: 'VT323', monospace; font-size: 2.5rem; color: #f1faee; margin-bottom: 20px;">
                            ${roomConfig.icon} ${roomConfig.name}
                        </h2>
                        <p style="font-family: 'Inter', sans-serif; font-size: 1.1rem; color: #ccc; margin-bottom: 30px;">
                            Alive & Well listening party
                        </p>
                        <div style="display: flex; gap: 20px; justify-content: center;">
                            <button onclick="selectListeningMode('room')" style="
                                font-family: 'VT323', monospace;
                                font-size: 1.5rem;
                                padding: 15px 30px;
                                background: rgba(124, 194, 155, 0.2);
                                border: 2px solid #7fc29b;
                                border-radius: 8px;
                                color: #7fc29b;
                                cursor: pointer;
                            ">üåç join live playback</button>
                            <button onclick="selectListeningMode('solo')" style="
                                font-family: 'VT323', monospace;
                                font-size: 1.5rem;
                                padding: 15px 30px;
                                background: rgba(106, 76, 147, 0.2);
                                border: 2px solid #6a4c93;
                                border-radius: 8px;
                                color: #6a4c93;
                                cursor: pointer;
                            ">üéß listen alone</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
                
                window.selectListeningMode = function(mode) {
                    listeningMode = mode;
                    if (mode === 'solo') {
                        document.getElementById('modeIndicator').innerHTML = 'üéß solo listening';
                        document.getElementById('modeIndicator').style.color = '#6a4c93';
                    }
                    document.body.removeChild(modal);
                    console.log('‚úì User selected:', mode);
                };
            }
        }

        // ============================================
        // PRIVATE POD FUNCTIONS
        // ============================================

        // Tab switching
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                const tab = this.getAttribute('data-tab');
                
                // Update active tab
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                
                // Show corresponding section
                document.querySelectorAll('.queue-section').forEach(s => s.classList.remove('active'));
                if (tab === 'shared') {
                    document.getElementById('sharedQueue').classList.add('active');
                    // Don't auto-exit pod - user might just be checking shared queue
                } else if (tab === 'pod') {
                    document.getElementById('privatePod').classList.add('active');
                    // Don't auto-enter pod - user might just be browsing
                }
            });
        });

        // Update avatar appearance based on pod mode
        function updatePodModeIndicator() {
            const currentAvatar = document.querySelector('.avatar.current-user');
            const modeIndicator = document.getElementById('modeIndicator');
            const modeToggleBtn = document.getElementById('modeToggleBtn');
            
            if (inPodMode) {
                // Pod mode: grey avatar
                if (currentAvatar) {
                    currentAvatar.style.opacity = '0.6';
                    currentAvatar.style.transform = 'scale(0.9)';
                    currentAvatar.style.filter = 'grayscale(0.5)';
                }
                
                // Update mode indicator
                if (modeIndicator) {
                    modeIndicator.innerHTML = 'üéß in your pod';
                    modeIndicator.style.color = '#6a4c93';
                }
                
                // Update toggle button
                if (modeToggleBtn) {
                    modeToggleBtn.innerHTML = 'üåç exit pod';
                    modeToggleBtn.style.background = 'rgba(106, 76, 147, 0.2)';
                    modeToggleBtn.style.borderColor = '#6a4c93';
                    modeToggleBtn.onclick = exitPodMode;
                }
            } else {
                // Normal appearance
                if (currentAvatar) {
                    currentAvatar.style.opacity = '1';
                    currentAvatar.style.transform = 'scale(1)';
                    currentAvatar.style.filter = 'none';
                }
                
                // Restore normal mode toggle
                if (modeToggleBtn) {
                    modeToggleBtn.onclick = window.toggleListeningMode;
                }
                
                // Update based on current listening mode
                if (modeIndicator && modeToggleBtn) {
                    if (listeningMode === 'room') {
                        modeIndicator.innerHTML = 'üåç listening with room';
                        modeIndicator.style.color = '#7fc29b';
                        modeToggleBtn.innerHTML = 'üéß solo';
                        modeToggleBtn.style.background = 'rgba(106, 76, 147, 0.2)';
                        modeToggleBtn.style.borderColor = '#6a4c93';
                    } else {
                        modeIndicator.innerHTML = 'üéß solo listening';
                        modeIndicator.style.color = '#6a4c93';
                        modeToggleBtn.innerHTML = 'üåç rejoin';
                        modeToggleBtn.style.background = 'rgba(124, 194, 155, 0.2)';
                        modeToggleBtn.style.borderColor = '#7fc29b';
                    }
                }
            }
        }

        // Exit pod mode
        function exitPodMode() {
            inPodMode = false;
            
            // Update UI
            document.getElementById('modeIndicator').innerHTML = 'üåç shared queue';
            document.getElementById('modeIndicator').style.color = '#7fc29b';
            document.getElementById('modeToggleBtn').innerHTML = 'üéß private pod';
            document.getElementById('modeToggleBtn').style.background = 'rgba(106, 76, 147, 0.2)';
            
            // Restore avatar appearance
            const currentAvatar = document.querySelector('.avatar.current-user');
            if (currentAvatar) {
                currentAvatar.style.opacity = '1';
                currentAvatar.style.transform = 'scale(1)';
                currentAvatar.style.filter = 'none';
            }
            
            // Stop current playback
            if (isPlaying) {
                audioPlayer.pause();
                isPlaying = false;
                document.getElementById('playBtn').textContent = '‚ñ∂';
            }
            
            console.log('‚úì Switched to SHARED QUEUE');
        }

        // Hide pod tab if uploads not allowed
        if (!roomConfig.uploadsAllowed && roomName !== 'sanctuary') {
            const podTab = document.querySelector('[data-tab="pod"]');
            if (podTab) podTab.style.display = 'none';
        }

        // Handle pod file upload
        window.handlePodFileUpload = async function(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // Use FileReader to convert to data URL (works better than blob URLs)
            const reader = new FileReader();
            reader.onload = function(e) {
                const track = {
                    title: file.name.replace(/\.[^/.]+$/, ''),
                    artist: 'Local Upload',
                    url: e.target.result, // Data URL instead of blob
                    duration: '0:00',
                    note: '',
                    isLocalUpload: true // Mark as local so we don't try to save it
                };
                
                podQueue.push(track);
                // Don't save local uploads to storage (too big)
                renderPodQueue();
                
                alert('‚úì Track added to pod!\n\n‚ö†Ô∏è Local uploads are session-only.\nThey will be lost on page refresh.');
            };
            reader.readAsDataURL(file);
        };

        // Render pod queue
        function renderPodQueue() {
            const list = document.getElementById('podQueueList');
            if (!list) return;
            
            list.innerHTML = '';
            
            podQueue.forEach((track, index) => {
                const isCurrentlyPlaying = inPodMode && currentTrackIndex === index && isPlaying;
                const item = document.createElement('div');
                item.className = 'pod-track-item';
                item.style.cursor = 'pointer';
                
                // Click entire row to play
                item.onclick = () => {
                    console.log('Pod track clicked:', index, track.title);
                    console.log('Before - inPodMode:', inPodMode);
                    inPodMode = true;
                    console.log('After - inPodMode:', inPodMode);
                    updatePodModeIndicator();
                    playTrack(index);
                };
                
                item.innerHTML = `
                    <div class="pod-track-controls" onclick="event.stopPropagation()">
                        <button class="pod-track-btn" onclick="movePodTrack(${index}, -1)" 
                                style="background: rgba(168, 212, 232, 0.2); border-color: #a8dae8; color: #a8dae8;"
                                ${index === 0 ? 'disabled' : ''}>‚Üë</button>
                        <button class="pod-track-btn" onclick="movePodTrack(${index}, 1)"
                                style="background: rgba(168, 212, 232, 0.2); border-color: #a8dae8; color: #a8dae8;"
                                ${index === podQueue.length - 1 ? 'disabled' : ''}>‚Üì</button>
                    </div>
                    <div class="pod-track-info">
                        <div style="font-size: 1rem; margin-bottom: 3px; ${isCurrentlyPlaying ? 'color: #6a4c93; font-weight: 600;' : ''}">${track.title}</div>
                        <div style="font-size: 0.85rem; color: #888;">${track.artist}</div>
                        <input type="text" class="pod-track-note" placeholder="add note..." 
                               value="${track.note || ''}" 
                               onclick="event.stopPropagation()"
                               onchange="updatePodTrackNote(${index}, this.value)">
                    </div>
                    <div style="display: flex; gap: 8px;" onclick="event.stopPropagation()">
                        <button class="pod-track-btn" onclick="sharePodTrackToRoom(${index})"
                                style="background: rgba(124, 194, 155, 0.2); border-color: #7fc29b; color: #7fc29b; width: auto; padding: 0 12px;">
                            üì§ share
                        </button>
                        <button class="pod-track-btn" onclick="removePodTrack(${index})"
                                style="background: rgba(214, 40, 40, 0.2); border-color: #d62828; color: #d62828;">
                            ‚úï
                        </button>
                    </div>
                `;
                list.appendChild(item);
            });
        }

        // Move track in pod queue
        window.movePodTrack = function(index, direction) {
            const newIndex = index + direction;
            if (newIndex < 0 || newIndex >= podQueue.length) return;
            
            [podQueue[index], podQueue[newIndex]] = [podQueue[newIndex], podQueue[index]];
            savePodToStorage();
            renderPodQueue();
        };

        // Update track note
        window.updatePodTrackNote = function(index, note) {
            podQueue[index].note = note;
            savePodToStorage();
        };

        // Remove track from pod
        window.removePodTrack = function(index) {
            podQueue.splice(index, 1);
            savePodToStorage();
            renderPodQueue();
        };

        // Share single track to room (90s cooldown)
        window.sharePodTrackToRoom = function(index) {
            const now = Date.now();
            const timeSinceLastShare = now - lastShareTime;
            
            if (timeSinceLastShare < 90000 && lastShareTime !== 0) {
                const remaining = Math.ceil((90000 - timeSinceLastShare) / 1000);
                alert(`‚è±Ô∏è Cooldown active!\n\nWait ${remaining} seconds before sharing another track.\n\n(Or use "Push All" to queue multiple tracks at once)`);
                return;
            }
            
            const track = podQueue[index];
            roomQueue.push({...track, type: 'file'});
            addToQueueUI(track.title, track.artist, track.duration || '0:00');
            lastShareTime = now;
            
            alert(`‚úì Shared: ${track.title}\n\nNext share available in 90 seconds.`);
        };

        // Push all to room (1 per minute, max 10)
        window.pushAllToRoom = function() {
            if (podQueue.length === 0) {
                alert('Your pod is empty!');
                return;
            }
            
            const tracksToSend = podQueue.slice(0, 10);
            
            if (bulkPushInterval) {
                alert('Bulk push already in progress!');
                return;
            }
            
            const confirmed = confirm(
                `üì§ Queue ${tracksToSend.length} tracks to room?\n\n` +
                `‚Ä¢ Tracks will be added one per minute\n` +
                `‚Ä¢ First track adds immediately\n` +
                `‚Ä¢ Tracks stay in your pod\n\n` +
                `Continue?`
            );
            
            if (!confirmed) return;
            
            bulkPushCount = 0;
            bulkPushTotal = tracksToSend.length;
            
            // Add first track immediately
            const firstTrack = tracksToSend[0];
            roomQueue.push({...firstTrack, type: 'file'});
            addToQueueUI(firstTrack.title, firstTrack.artist, firstTrack.duration || '0:00');
            bulkPushCount++;
            
            if (tracksToSend.length === 1) {
                alert('‚úì Track added to room queue!');
                return;
            }
            
            // Show progress UI
            document.getElementById('bulkPushStatus').style.display = 'block';
            updateBulkPushProgress();
            
            // Add remaining tracks every 60 seconds
            let index = 1;
            bulkPushInterval = setInterval(() => {
                if (index >= tracksToSend.length) {
                    cancelBulkPush();
                    alert(`‚úì All ${bulkPushTotal} tracks added to room queue!`);
                    return;
                }
                
                const track = tracksToSend[index];
                roomQueue.push({...track, type: 'file'});
                addToQueueUI(track.title, track.artist, track.duration || '0:00');
                bulkPushCount++;
                updateBulkPushProgress();
                index++;
            }, 60000); // 60 seconds
        };

        // Update bulk push progress
        function updateBulkPushProgress() {
            const remaining = bulkPushTotal - bulkPushCount;
            const seconds = remaining * 60;
            document.getElementById('bulkPushProgress').textContent = 
                `${bulkPushCount} / ${bulkPushTotal} tracks sent | Next in ${seconds} seconds`;
        }

        // Cancel bulk push
        window.cancelBulkPush = function() {
            if (bulkPushInterval) {
                clearInterval(bulkPushInterval);
                bulkPushInterval = null;
            }
            document.getElementById('bulkPushStatus').style.display = 'none';
        };

        // Toggle pod loop mode
        window.togglePodLoop = function() {
            podLoopMode = document.getElementById('podLoopMode').checked;
        };

        // Pre-fill sanctuary pod
        if (roomName === 'sanctuary') {
            const sanctuaryTracks = roomPlaylists.sanctuary || [];
            if (sanctuaryTracks.length > 0 && podQueue.length === 0) {
                podQueue = sanctuaryTracks.map(t => ({...t, note: ''}));
                savePodToStorage();
            }
        }

        // Listen to room queue updates
        function listenToRoomQueue() {
            const queueRef = collection(db, 'rooms', roomName, 'queue');
            const q = query(queueRef, orderBy('uploadedAt', 'asc'));
            
            onSnapshot(q, (snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    const track = { id: change.doc.id, ...change.doc.data() };
                    
                    if (change.type === 'added') {
                        // Check if track already exists in local queue
                        const exists = roomQueue.find(t => t.id === track.id);
                        if (!exists) {
                            console.log('New track added to room queue:', track.title);
                            roomQueue.push(track);
                            addToQueueUI(track.title, track.artist, track.duration || '0:00');
                            
                            // Show notification if uploaded by someone else
                            if (track.uploadedBy !== currentUser.uid) {
                                showNotification(`üéµ ${track.artist} added: ${track.title}`);
                            }
                        }
                    }
                    
                    if (change.type === 'removed') {
                        console.log('Track removed from room queue:', track.title);
                        const index = roomQueue.findIndex(t => t.id === track.id);
                        if (index !== -1) {
                            roomQueue.splice(index, 1);
                            // TODO: Update queue UI to reflect removal
                        }
                    }
                });
            }, (error) => {
                console.error('Queue listener error:', error);
            });
        }

        // Show notification helper
        function showNotification(message) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 80px;
                right: 20px;
                background: rgba(10, 10, 10, 0.95);
                border: 2px solid #7fc29b;
                border-radius: 8px;
                padding: 15px 20px;
                font-family: 'VT323', monospace;
                font-size: 1.2rem;
                color: #7fc29b;
                z-index: 10000;
                animation: slideIn 0.3s ease;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transition = 'opacity 0.3s';
                setTimeout(() => document.body.removeChild(notification), 300);
            }, 3000);
        }

        // Initialize audio events
        if (audioPlayer) {
            audioPlayer.addEventListener('ended', () => {
                // Auto-advance to next track
                playNextInQueue();
            });

            audioPlayer.addEventListener('timeupdate', () => {
                updateProgressBar();
            });
        }

        // Toggle between shared queue and private pod
        window.toggleQueueMode = function() {
            if (inPodMode) {
                // Switch to shared queue
                exitPodMode();
            } else {
                // Switch to private pod
                enterPodMode();
            }
        };

        // Enter pod mode
        function enterPodMode() {
            inPodMode = true;
            
            // Update UI
            document.getElementById('modeIndicator').innerHTML = 'üéß private pod';
            document.getElementById('modeIndicator').style.color = '#6a4c93';
            document.getElementById('modeToggleBtn').innerHTML = 'üåç shared queue';
            document.getElementById('modeToggleBtn').style.background = 'rgba(124, 194, 155, 0.2)';
            
            // Grey out avatar
            updatePodModeIndicator();
            
            // Stop current playback
            if (isPlaying) {
                audioPlayer.pause();
                isPlaying = false;
                document.getElementById('playBtn').textContent = '‚ñ∂';
            }
            
            console.log('‚úì Switched to PRIVATE POD');
        }

        // Play/Pause
        window.togglePlayback = function() {
            const currentQueue = inPodMode ? podQueue : roomQueue;
            
            if (!audioPlayer || currentQueue.length === 0) {
                alert('No tracks in queue. Upload or add a track first.');
                return;
            }

            if (isPlaying) {
                audioPlayer.pause();
                isPlaying = false;
                document.getElementById('playBtn').textContent = '‚ñ∂';
            } else {
                if (!audioPlayer.src && currentQueue.length > 0) {
                    playTrack(0);
                } else {
                    audioPlayer.play();
                    isPlaying = true;
                    document.getElementById('playBtn').textContent = '‚è∏';
                }
            }
        };

        // Play specific track
        function playTrack(index) {
            // Simple: pod queue or room queue
            const currentQueue = inPodMode ? podQueue : roomQueue;
            
            if (index < 0 || index >= currentQueue.length) return;
            
            currentTrackIndex = index;
            const track = currentQueue[index];
            
            // If track has no type, or type is 'file' or 'url', play it directly
            if (!track.type || track.type === 'file' || track.type === 'url') {
                audioPlayer.src = track.url;
                audioPlayer.play().catch(error => {
                    console.error('Playback error:', error);
                    alert(`Could not play track: ${track.title}\n\nMake sure the file exists at: ${track.url}`);
                });
                isPlaying = true;
                document.getElementById('playBtn').textContent = '‚è∏';
                updateNowPlaying(track);
            } else {
                alert('This track type requires additional integration (YouTube/SoundCloud API)');
            }
        }

        // Next track
        window.nextTrack = function() {
            playNextInQueue();
        };

        // Previous track
        window.previousTrack = function() {
            playPreviousInQueue();
        };

        // Play next in queue
        function playNextInQueue() {
            const currentQueue = inPodMode ? podQueue : roomQueue;
            
            if (currentTrackIndex < currentQueue.length - 1) {
                playTrack(currentTrackIndex + 1);
            } else {
                // If in pod mode with loop enabled, restart
                if (inPodMode && podLoopMode) {
                    playTrack(0);
                } else {
                    // Stop at end
                    isPlaying = false;
                    document.getElementById('playBtn').textContent = '‚ñ∂';
                }
            }
        }

        // Play previous in queue
        function playPreviousInQueue() {
            const currentQueue = inPodMode ? podQueue : roomQueue;
            
            if (currentTrackIndex > 0) {
                playTrack(currentTrackIndex - 1);
            } else {
                playTrack(currentQueue.length - 1);
            }
        }

        // Update now playing display
        function updateNowPlaying(track) {
            if (!track) {
                const currentQueue = listeningMode === 'room' ? roomQueue : soloQueue;
                if (currentQueue.length === 0) return;
                track = currentQueue[currentTrackIndex];
            }
            
            document.getElementById('nowPlayingTitle').textContent = track.title;
            document.getElementById('nowPlayingArtist').textContent = track.artist;
        }

        // Progress bar update
        function updateProgressBar() {
            if (!audioPlayer || !audioPlayer.duration) return;
            const progress = (audioPlayer.currentTime / audioPlayer.duration) * 100;
            // TODO: Update visual progress bar if added to UI
        }

        // ============================================
        // VOTING SYSTEM
        // ============================================

        function initiateSkipVote() {
            // Get actual room user count from presence
            const roomUserCount = usersInRoom.length + 1; // +1 for current user
            const requiredVotes = Math.ceil(roomUserCount * 0.7); // 70% threshold
            
            activeVote = {
                type: 'skip',
                yesVotes: 0,
                noVotes: 0,
                totalUsers: roomUserCount,
                requiredVotes: requiredVotes,
                voters: new Set()
            };
            
            userVote = null;
            showVoteNotification();
            updateVoteDisplay();
            
            // TODO: Broadcast vote to Firebase
            // TODO: Set timeout to close vote after 30 seconds
        }

        function showVoteNotification() {
            document.getElementById('voteNotification').classList.add('show');
        }

        function hideVoteNotification() {
            document.getElementById('voteNotification').classList.remove('show');
        }

        window.castVote = function(vote) {
            if (!activeVote || userVote !== null) return;
            
            userVote = vote;
            
            if (vote) {
                activeVote.yesVotes++;
            } else {
                activeVote.noVotes++;
            }
            
            activeVote.voters.add(currentUser.uid);
            updateVoteDisplay();
            
            // Check if vote passes
            if (activeVote.yesVotes >= activeVote.requiredVotes) {
                // Vote passed! Skip track
                setTimeout(() => {
                    hideVoteNotification();
                    playNextInQueue();
                    activeVote = null;
                    userVote = null;
                }, 1000);
            } else if (activeVote.yesVotes + activeVote.noVotes >= activeVote.totalUsers) {
                // All votes in, but didn't pass
                setTimeout(() => {
                    hideVoteNotification();
                    activeVote = null;
                    userVote = null;
                }, 1500);
            }
            
            // TODO: Broadcast vote to Firebase
        };

        function updateVoteDisplay() {
            if (!activeVote) return;
            
            const totalVotes = activeVote.yesVotes + activeVote.noVotes;
            const progress = (activeVote.yesVotes / activeVote.requiredVotes) * 100;
            
            document.getElementById('voteProgress').textContent = 
                `${activeVote.yesVotes} / ${activeVote.requiredVotes} votes (need 70%)`;
            document.getElementById('voteBarFill').style.width = `${Math.min(progress, 100)}%`;
        }

        // ============================================
        // QUEUE MANAGEMENT
        // ============================================

        // Modified file upload
        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // Show uploading status
            const uploadingMsg = document.createElement('div');
            uploadingMsg.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(10, 10, 10, 0.95);
                border: 2px solid #7fc29b;
                border-radius: 12px;
                padding: 30px;
                z-index: 10001;
                text-align: center;
                font-family: 'VT323', monospace;
                font-size: 1.5rem;
                color: #7fc29b;
            `;
            uploadingMsg.innerHTML = 'üì§ Uploading to room...<br><span style="font-size: 1rem; color: #888;">Please wait</span>';
            document.body.appendChild(uploadingMsg);
            
            try {
                // Generate unique filename
                const timestamp = Date.now();
                const sanitizedFilename = file.name.replace(/[^a-zA-Z0-9._-]/g, '_');
                const storagePath = `rooms/${roomName}/uploads/${currentUser.uid}_${timestamp}_${sanitizedFilename}`;
                
                // Upload to Firebase Storage
                const storageRef = ref(storage, storagePath);
                const snapshot = await uploadBytes(storageRef, file);
                console.log('‚úì File uploaded:', snapshot.metadata.fullPath);
                
                // Get download URL
                const downloadURL = await getDownloadURL(storageRef);
                console.log('‚úì Download URL:', downloadURL);
                
                // Create track object
                const track = {
                    type: 'file',
                    title: file.name.replace(/\.[^/.]+$/, ''),
                    artist: currentUserData.username || 'Unknown',
                    url: downloadURL,
                    duration: '0:00',
                    uploadedBy: currentUser.uid,
                    uploadedAt: new Date().toISOString(),
                    storagePath: storagePath
                };
                
                // Add to Firestore room queue
                await addDoc(collection(db, 'rooms', roomName, 'queue'), track);
                console.log('‚úì Track added to room queue');
                
                // Add to local queue
                roomQueue.push(track);
                addToQueueUI(track.title, track.artist, track.duration);
                
                // Remove uploading message
                document.body.removeChild(uploadingMsg);
                
                // Show success
                alert(`‚úì ${track.title} added to room queue!`);
                
                // Auto-play if nothing playing and not in pod mode
                if (!isPlaying && !inPodMode) {
                    playTrack(roomQueue.length - 1);
                }
                
            } catch (error) {
                console.error('Upload error:', error);
                document.body.removeChild(uploadingMsg);
                alert(`‚ùå Upload failed: ${error.message}\n\nMake sure you're connected to the internet.`);
            }
            
            // Reset file input
            event.target.value = '';
        }

        // Modified URL handler
        function addFromURL() {
            const url = document.getElementById('urlInput').value.trim();
            if (!url) return;
            
            let track = {
                type: 'url',
                title: 'External Track',
                artist: 'External Link',
                url: url,
                duration: '0:00',
                uploadedBy: currentUser.uid
            };
            
            if (url.includes('youtube') || url.includes('youtu.be')) {
                alert('YouTube playback requires iframe API. Coming soon!');
                document.getElementById('urlInput').value = '';
                return;
            } else if (url.includes('soundcloud')) {
                alert('SoundCloud playback requires widget API. Coming soon!');
                document.getElementById('urlInput').value = '';
                return;
            }
            
            // Add to appropriate queue
            if (listeningMode === 'room') {
                roomQueue.push(track);
                // TODO: Sync to Firebase
            } else {
                soloQueue.push(track);
            }
            
            addToQueueUI(track.title, track.artist, track.duration);
            document.getElementById('urlInput').value = '';
            
            if (!isPlaying) {
                playTrack(0);
            }
        }

        // Enhanced queue UI
        function addToQueueUI(title, artist, time) {
            const queueList = document.getElementById('queueList');
            const currentQueue = listeningMode === 'room' ? roomQueue : soloQueue;
            const trackIndex = currentQueue.length - 1;
            
            const item = document.createElement('div');
            item.className = 'queue-item';
            item.onclick = () => {
                if (listeningMode === 'solo') {
                    playTrack(trackIndex);
                } else {
                    alert('In room mode, track selection requires majority vote (coming soon)');
                }
            };
            item.style.cursor = 'pointer';
            item.innerHTML = `
                <div class="queue-item-info">
                    <div class="queue-item-title">${title}</div>
                    <div class="queue-item-artist">${artist}</div>
                </div>
                <div class="queue-item-time">${time}</div>
            `;
            queueList.appendChild(item);
        }

        // Expose music functions to window for onclick handlers
        window.handleFileUpload = handleFileUpload;
        window.addFromURL = addFromURL;

    </script>

    <!-- Music Queue Modal -->
    <div class="modal" id="queueModal" style="display: none;">
        <div class="modal-overlay" onclick="closeQueue()"></div>
        <div class="modal-content">
            <div class="modal-header">
                <h2>music queue</h2>
                <button class="modal-close" onclick="closeQueue()">√ó</button>
            </div>
            
            <div class="queue-tabs">
                <button class="tab-btn active" data-tab="shared">shared queue</button>
                <button class="tab-btn" data-tab="pod">private pod</button>
            </div>

            <div id="sharedQueue" class="queue-section active">
                <div class="upload-area">
                    <div class="upload-box" onclick="document.getElementById('fileUpload').click()">
                        <input type="file" id="fileUpload" accept="audio/mpeg,audio/wav,audio/mp4,audio/x-m4a,audio/aac,audio/ogg,audio/flac,audio/x-ms-wma,.mp3,.wav,.m4a,.aac,.ogg,.flac,.wma" style="display:none" onchange="handleFileUpload(event)">
                        <span class="upload-icon">üìÅ</span>
                        <p>drop audio or click to upload</p>
                    </div>
                </div>

                <div class="queue-list" id="queueList">
                    <!-- Queue tracks will appear here -->
                </div>
            </div>

            <div id="privatePod" class="queue-section">
                <div class="pod-controls">
                    <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 15px;">
                        <input type="checkbox" id="podLoopMode" onchange="togglePodLoop()" style="transform: scale(1.2);">
                        <span style="font-family: 'VT323', monospace; font-size: 1.2rem;">üîÅ loop pod</span>
                    </label>
                    <button class="pod-action-btn" onclick="pushAllToRoom()" style="background: rgba(124, 194, 155, 0.2); border-color: #7fc29b; color: #7fc29b;">
                        üì§ push all to room (max 10)
                    </button>
                </div>

                <div class="upload-area">
                    <div class="upload-box" onclick="document.getElementById('podFileUpload').click()">
                        <input type="file" id="podFileUpload" accept="audio/mpeg,audio/wav,audio/mp4,audio/x-m4a,audio/aac,audio/ogg,audio/flac,audio/x-ms-wma,.mp3,.wav,.m4a,.aac,.ogg,.flac,.wma" style="display:none" onchange="handlePodFileUpload(event)">
                        <span class="upload-icon">üéß</span>
                        <p>add to your pod</p>
                    </div>
                </div>

                <div class="queue-list" id="podQueueList">
                    <!-- Pod tracks will appear here -->
                </div>

                <div id="bulkPushStatus" style="display: none; padding: 15px; background: rgba(124, 194, 155, 0.1); border: 1px solid #7fc29b; border-radius: 8px; margin-top: 15px; font-family: 'VT323', monospace; text-align: center;">
                    <div style="font-size: 1.3rem; margin-bottom: 8px;">‚è±Ô∏è pushing to room...</div>
                    <div id="bulkPushProgress" style="font-size: 1.1rem; color: #7fc29b;"></div>
                    <button onclick="cancelBulkPush()" style="margin-top: 10px; padding: 8px 16px; background: rgba(214, 40, 40, 0.2); border: 1px solid #d62828; border-radius: 6px; color: #d62828; cursor: pointer; font-family: 'VT323', monospace; font-size: 1rem;">cancel remaining</button>
                </div>
            </div>
        </div>
    </div>


    <!-- Audio Player (Hidden) -->
    <audio id="audioPlayer" style="display: none;"></audio>


    <!-- Vote Notification (disabled for v1) -->
    <div class="vote-notification" id="voteNotification" style="display: none;">
        <div class="vote-title">skip track?</div>
        <div class="vote-options">
            <button class="vote-btn yes" onclick="castVote(true)">‚úì yes</button>
            <button class="vote-btn no" onclick="castVote(false)">‚úó no</button>
        </div>
        <div class="vote-progress" id="voteProgress">0 / 0 votes (need 70%)</div>
        <div class="vote-bar">
            <div class="vote-bar-fill" id="voteBarFill"></div>
        </div>
    </div>

</body>
</html>
